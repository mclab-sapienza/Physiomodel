/* update bound parameters and variable attributes (start, nominal, min, max) */
/* Simulation code for Test generated by the OpenModelica Compiler v1.9.6. */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_json.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <string.h>

#include "Test_functions.h"
#include "Test_model.h"
#include "Test_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif
#if defined(__cplusplus)
extern "C" {
#endif

int Test_updateBoundVariableAttributes(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  
  /* min ******************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating min-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* max ******************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating max-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* nominal **************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating nominal-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* start ****************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating start-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  TRACE_POP
  return 0;
}


/*
 equation index: 14
 type: SIMPLE_ASSIGN
 NormalFillingPressure = 0.06799440789473685 * NormalEndDiastolicVolume ^ DIVISION(1.0, n_Diastole)
 */
void Test_eqFunction_14(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,14};
  modelica_real tmp0;
  modelica_real tmp1;
  modelica_real tmp2;
  modelica_real tmp3;
  modelica_real tmp4;
  modelica_real tmp5;
  modelica_real tmp6;
  tmp0 = $PNormalEndDiastolicVolume;
  tmp1 = DIVISION_SIM(1.0,$Pn_Diastole,"n_Diastole",equationIndexes);
  if(tmp0 < 0.0 && tmp1 != 0.0)
  {
    tmp3 = modf(tmp1, &tmp4);
    
    if(tmp3 > 0.5)
    {
      tmp3 -= 1.0;
      tmp4 += 1.0;
    }
    else if(tmp3 < -0.5)
    {
      tmp3 += 1.0;
      tmp4 -= 1.0;
    }
    
    if(fabs(tmp3) < 1e-10)
      tmp2 = pow(tmp0, tmp4);
    else
    {
      tmp6 = modf(1.0/tmp1, &tmp5);
      if(tmp6 > 0.5)
      {
        tmp6 -= 1.0;
        tmp5 += 1.0;
      }
      else if(tmp6 < -0.5)
      {
        tmp6 += 1.0;
        tmp5 -= 1.0;
      }
      if(fabs(tmp6) < 1e-10 && ((unsigned long)tmp5 & 1))
      {
        tmp2 = -pow(-tmp0, tmp3)*pow(tmp0, tmp4);
      }
      else
      {
        throwStreamPrint(threadData, "Invalid root: (%g)^(%g)", tmp0, tmp1);
      }
    }
  }
  else
  {
    tmp2 = pow(tmp0, tmp1);
  }
  if(isnan(tmp2) || isinf(tmp2))
  {
    throwStreamPrint(threadData, "Invalid root: (%g)^(%g)", tmp0, tmp1);
  }
  $PNormalFillingPressure = (0.06799440789473685) * (tmp2);
  TRACE_POP
}
/*
 equation index: 15
 type: SIMPLE_ASSIGN
 diastole._NormalEndDiastolicVolume = NormalEndDiastolicVolume
 */
void Test_eqFunction_15(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,15};
  $Pdiastole$PNormalEndDiastolicVolume = $PNormalEndDiastolicVolume;
  TRACE_POP
}
/*
 equation index: 16
 type: SIMPLE_ASSIGN
 diastole._NormalFillingPressure = NormalFillingPressure
 */
void Test_eqFunction_16(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,16};
  $Pdiastole$PNormalFillingPressure = $PNormalFillingPressure;
  TRACE_POP
}
/*
 equation index: 17
 type: SIMPLE_ASSIGN
 diastole._stiffnes = stiffnes
 */
void Test_eqFunction_17(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,17};
  $Pdiastole$Pstiffnes = $Pstiffnes;
  TRACE_POP
}
/*
 equation index: 18
 type: SIMPLE_ASSIGN
 diastole._n_Diastole = n_Diastole
 */
void Test_eqFunction_18(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,18};
  $Pdiastole$Pn_Diastole = $Pn_Diastole;
  TRACE_POP
}
/*
 equation index: 19
 type: SIMPLE_ASSIGN
 diastole._NormalExternalPressure = NormalExternalPressure
 */
void Test_eqFunction_19(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,19};
  $Pdiastole$PNormalExternalPressure = $PNormalExternalPressure;
  TRACE_POP
}
/*
 equation index: 20
 type: ALGORITHM
 
   assert(NormalEndDiastolicVolume >= 0.0, "Variable NormalEndDiastolicVolume out of [min, max] interval: NormalEndDiastolicVolume >= 0.0 has value: " + String(NormalEndDiastolicVolume, "g"));
 */
void Test_eqFunction_20(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,20};
  modelica_boolean tmp7;
  static const MMC_DEFSTRINGLIT(tmp8,105,"Variable NormalEndDiastolicVolume out of [min, max] interval: NormalEndDiastolicVolume >= 0.0 has value: ");
  modelica_string tmp9;
  static int tmp10 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp10)
  {
    tmp7 = GreaterEq($PNormalEndDiastolicVolume,0.0);
    if(!tmp7)
    {
      tmp9 = modelica_real_to_modelica_string_format($PNormalEndDiastolicVolume, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp8),tmp9);
      {
        FILE_INFO info = {"/Users/stefano/Repo/physiology/Physiomodel/Physiomodel/Build/CardioVascular/Heart/Diastole/Test.mo",19,3,19,72,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nNormalEndDiastolicVolume >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp10 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 21
 type: ALGORITHM
 
   assert(diastole.NormalEndDiastolicVolume >= 0.0, "Variable diastole.NormalEndDiastolicVolume out of [min, max] interval: diastole.NormalEndDiastolicVolume >= 0.0 has value: " + String(diastole.NormalEndDiastolicVolume, "g"));
 */
void Test_eqFunction_21(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,21};
  modelica_boolean tmp11;
  static const MMC_DEFSTRINGLIT(tmp12,123,"Variable diastole.NormalEndDiastolicVolume out of [min, max] interval: diastole.NormalEndDiastolicVolume >= 0.0 has value: ");
  modelica_string tmp13;
  static int tmp14 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp14)
  {
    tmp11 = GreaterEq($Pdiastole$PNormalEndDiastolicVolume,0.0);
    if(!tmp11)
    {
      tmp13 = modelica_real_to_modelica_string_format($Pdiastole$PNormalEndDiastolicVolume, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp12),tmp13);
      {
        FILE_INFO info = {"/Users/stefano/Repo/physiology/Physiomodel/Physiomodel/Build/CardioVascular/Heart/Diastole/Test.mo",7,3,7,64,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\ndiastole.NormalEndDiastolicVolume >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp14 = 1;
    }
  }
  TRACE_POP
}
int Test_updateBoundParameters(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  Test_eqFunction_14(data, threadData);

  Test_eqFunction_15(data, threadData);

  Test_eqFunction_16(data, threadData);

  Test_eqFunction_17(data, threadData);

  Test_eqFunction_18(data, threadData);

  Test_eqFunction_19(data, threadData);

  Test_eqFunction_20(data, threadData);

  Test_eqFunction_21(data, threadData);
  
  TRACE_POP
  return 0;
}

#if defined(__cplusplus)
}
#endif

