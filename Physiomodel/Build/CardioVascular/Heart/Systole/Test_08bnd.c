/* update bound parameters and variable attributes (start, nominal, min, max) */
/* Simulation code for Test generated by the OpenModelica Compiler v1.9.6. */

#include "openmodelica.h"
#include "openmodelica_func.h"
#include "simulation_data.h"
#include "simulation/simulation_info_json.h"
#include "simulation/simulation_runtime.h"
#include "util/omc_error.h"
#include "simulation/solver/model_help.h"
#include "simulation/solver/delay.h"
#include "simulation/solver/linearSystem.h"
#include "simulation/solver/nonlinearSystem.h"
#include "simulation/solver/mixedSystem.h"

#include <string.h>

#include "Test_functions.h"
#include "Test_model.h"
#include "Test_literals.h"




#if defined(HPCOM) && !defined(_OPENMP)
  #error "HPCOM requires OpenMP or the results are wrong"
#endif
#if defined(_OPENMP)
  #include <omp.h>
#else
  /* dummy omp defines */
  #define omp_get_max_threads() 1
#endif
#if defined(__cplusplus)
extern "C" {
#endif

int Test_updateBoundVariableAttributes(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  
  /* min ******************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating min-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* max ******************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating max-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* nominal **************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating nominal-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  /* start ****************************************************** */
  
  infoStreamPrint(LOG_INIT, 1, "updating start-values");
  if (ACTIVE_STREAM(LOG_INIT)) messageClose(LOG_INIT);
  
  TRACE_POP
  return 0;
}


/*
 equation index: 13
 type: SIMPLE_ASSIGN
 NormalEndSystolicVolume = (0.000431317816391127 * NormalSystolicPressure) ^ n_Systole
 */
void Test_eqFunction_13(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,13};
  modelica_real tmp0;
  modelica_real tmp1;
  modelica_real tmp2;
  modelica_real tmp3;
  modelica_real tmp4;
  modelica_real tmp5;
  modelica_real tmp6;
  tmp0 = (0.000431317816391127) * ($PNormalSystolicPressure);
  tmp1 = $Pn_Systole;
  if(tmp0 < 0.0 && tmp1 != 0.0)
  {
    tmp3 = modf(tmp1, &tmp4);
    
    if(tmp3 > 0.5)
    {
      tmp3 -= 1.0;
      tmp4 += 1.0;
    }
    else if(tmp3 < -0.5)
    {
      tmp3 += 1.0;
      tmp4 -= 1.0;
    }
    
    if(fabs(tmp3) < 1e-10)
      tmp2 = pow(tmp0, tmp4);
    else
    {
      tmp6 = modf(1.0/tmp1, &tmp5);
      if(tmp6 > 0.5)
      {
        tmp6 -= 1.0;
        tmp5 += 1.0;
      }
      else if(tmp6 < -0.5)
      {
        tmp6 += 1.0;
        tmp5 -= 1.0;
      }
      if(fabs(tmp6) < 1e-10 && ((unsigned long)tmp5 & 1))
      {
        tmp2 = -pow(-tmp0, tmp3)*pow(tmp0, tmp4);
      }
      else
      {
        throwStreamPrint(threadData, "Invalid root: (%g)^(%g)", tmp0, tmp1);
      }
    }
  }
  else
  {
    tmp2 = pow(tmp0, tmp1);
  }
  if(isnan(tmp2) || isinf(tmp2))
  {
    throwStreamPrint(threadData, "Invalid root: (%g)^(%g)", tmp0, tmp1);
  }
  $PNormalEndSystolicVolume = tmp2;
  TRACE_POP
}
/*
 equation index: 14
 type: SIMPLE_ASSIGN
 systole._n_Systole = n_Systole
 */
void Test_eqFunction_14(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,14};
  $Psystole$Pn_Systole = $Pn_Systole;
  TRACE_POP
}
/*
 equation index: 15
 type: SIMPLE_ASSIGN
 systole._NormalSystolicPressure = NormalSystolicPressure
 */
void Test_eqFunction_15(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,15};
  $Psystole$PNormalSystolicPressure = $PNormalSystolicPressure;
  TRACE_POP
}
/*
 equation index: 16
 type: SIMPLE_ASSIGN
 systole._NormalExternalPressure = NormalExternalPressure
 */
void Test_eqFunction_16(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,16};
  $Psystole$PNormalExternalPressure = $PNormalExternalPressure;
  TRACE_POP
}
/*
 equation index: 17
 type: SIMPLE_ASSIGN
 systole._NormalEndSystolicVolume = NormalEndSystolicVolume
 */
void Test_eqFunction_17(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,17};
  $Psystole$PNormalEndSystolicVolume = $PNormalEndSystolicVolume;
  TRACE_POP
}
/*
 equation index: 18
 type: SIMPLE_ASSIGN
 systole._additionalPressure_Systolic = additionalPressure_Systolic
 */
void Test_eqFunction_18(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,18};
  $Psystole$PadditionalPressure_Systolic = $PadditionalPressure_Systolic;
  TRACE_POP
}
/*
 equation index: 19
 type: ALGORITHM
 
   assert(NormalEndSystolicVolume >= 0.0, "Variable NormalEndSystolicVolume out of [min, max] interval: NormalEndSystolicVolume >= 0.0 has value: " + String(NormalEndSystolicVolume, "g"));
 */
void Test_eqFunction_19(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,19};
  modelica_boolean tmp7;
  static const MMC_DEFSTRINGLIT(tmp8,103,"Variable NormalEndSystolicVolume out of [min, max] interval: NormalEndSystolicVolume >= 0.0 has value: ");
  modelica_string tmp9;
  static int tmp10 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp10)
  {
    tmp7 = GreaterEq($PNormalEndSystolicVolume,0.0);
    if(!tmp7)
    {
      tmp9 = modelica_real_to_modelica_string_format($PNormalEndSystolicVolume, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp8),tmp9);
      {
        FILE_INFO info = {"/Users/stefano/Repo/physiology/Physiomodel/Physiomodel/Build/CardioVascular/Heart/Systole/Test.mo",3,3,3,121,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nNormalEndSystolicVolume >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp10 = 1;
    }
  }
  TRACE_POP
}
/*
 equation index: 20
 type: ALGORITHM
 
   assert(systole.NormalEndSystolicVolume >= 0.0, "Variable systole.NormalEndSystolicVolume out of [min, max] interval: systole.NormalEndSystolicVolume >= 0.0 has value: " + String(systole.NormalEndSystolicVolume, "g"));
 */
void Test_eqFunction_20(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  const int equationIndexes[2] = {1,20};
  modelica_boolean tmp11;
  static const MMC_DEFSTRINGLIT(tmp12,119,"Variable systole.NormalEndSystolicVolume out of [min, max] interval: systole.NormalEndSystolicVolume >= 0.0 has value: ");
  modelica_string tmp13;
  static int tmp14 = 0;
  modelica_metatype tmpMeta[1] __attribute__((unused)) = {0};
  if(!tmp14)
  {
    tmp11 = GreaterEq($Psystole$PNormalEndSystolicVolume,0.0);
    if(!tmp11)
    {
      tmp13 = modelica_real_to_modelica_string_format($Psystole$PNormalEndSystolicVolume, (modelica_string) mmc_strings_len1[103]);
      tmpMeta[0] = stringAppend(MMC_REFSTRINGLIT(tmp12),tmp13);
      {
        FILE_INFO info = {"/Users/stefano/Repo/physiology/Physiomodel/Physiomodel/CardioVascular/Heart/Systole.mo",22,5,23,85,0};
        omc_assert_warning(info, "The following assertion has been violated %sat time %f\nsystole.NormalEndSystolicVolume >= 0.0", initial() ? "during initialization " : "", data->localData[0]->timeValue);
        omc_assert_warning_withEquationIndexes(info, equationIndexes, MMC_STRINGDATA(tmpMeta[0]));
      }
      tmp14 = 1;
    }
  }
  TRACE_POP
}
int Test_updateBoundParameters(DATA *data, threadData_t *threadData)
{
  TRACE_PUSH
  Test_eqFunction_13(data, threadData);

  Test_eqFunction_14(data, threadData);

  Test_eqFunction_15(data, threadData);

  Test_eqFunction_16(data, threadData);

  Test_eqFunction_17(data, threadData);

  Test_eqFunction_18(data, threadData);

  Test_eqFunction_19(data, threadData);

  Test_eqFunction_20(data, threadData);
  
  TRACE_POP
  return 0;
}

#if defined(__cplusplus)
}
#endif

